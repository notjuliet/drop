<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>drop</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body
    class="bg-bg text-text min-h-screen flex flex-col items-center justify-center px-4 font-sans"
  >
    <div class="w-full max-w-md">
      <h1 class="text-lg font-medium mb-6">
        <a
          href="/"
          class="text-text no-underline hover:text-accent transition-colors"
          >drop</a
        >
      </h1>

      <!-- Metadata card (shown after HEAD) -->
      <div id="meta" class="hidden">
        <div class="font-mono text-base mb-1" id="meta-name"></div>
        <div class="flex gap-3 text-muted text-xs mb-1">
          <span id="meta-size"></span>
          <span id="meta-expiry"></span>
        </div>
        <div id="burn-warning" class="hidden mb-3">
          <span
            class="inline-block text-danger text-[10px] font-medium rounded-full px-2 py-0.5"
            style="
              background: color-mix(
                in srgb,
                var(--color-danger) 10%,
                transparent
              );
            "
          >
            Burns after viewing
          </span>
        </div>
        <div class="mt-4">
          <button
            id="load-btn"
            class="w-full bg-accent text-white border-none rounded-md py-2.5 text-sm font-medium cursor-pointer hover:bg-accent-hover disabled:opacity-40 disabled:cursor-not-allowed transition-colors"
          >
            View
          </button>
        </div>
      </div>

      <!-- Content (shown after GET + decrypt) -->
      <div id="content-wrapper" class="hidden relative">
        <div class="absolute top-2 right-2 flex gap-1 z-10">
          <button
            id="copy"
            class="bg-surface text-muted hover:text-text border border-border rounded-md p-1.5 cursor-pointer transition-colors"
            title="Copy"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="14"
              height="14"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
              <path
                d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
              />
            </svg>
          </button>
          <button
            id="raw"
            class="bg-surface text-muted hover:text-text border border-border rounded-md p-1.5 cursor-pointer transition-colors"
            title="Raw"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="14"
              height="14"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="4 7 4 4 20 4 20 7" />
              <line x1="9" x2="15" y1="20" y2="20" />
              <line x1="12" x2="12" y1="4" y2="20" />
            </svg>
          </button>
        </div>
        <div
          id="content"
          class="w-full bg-surface border border-border rounded-lg p-4 pt-10 font-mono text-xs leading-relaxed whitespace-pre-wrap wrap-break-word max-h-[60vh] overflow-auto"
        ></div>
      </div>

      <div id="image-container" class="hidden w-full">
        <img
          id="image-el"
          src=""
          alt=""
          class="max-w-full rounded-lg shadow-sm"
        />
      </div>

      <div id="binary-container" class="hidden">
        <div class="bg-surface border border-border rounded-lg p-4 text-center">
          <p id="binary-name" class="font-mono text-sm mb-3"></p>
          <button
            id="download"
            class="w-full bg-accent text-white border-none rounded-md py-2.5 text-sm font-medium cursor-pointer hover:bg-accent-hover transition-colors"
          >
            Download
          </button>
        </div>
      </div>

      <div id="burn-notice" class="hidden mt-3 text-xs text-danger">
        This file has been burned and can no longer be viewed.
      </div>

      <div id="image-actions" class="hidden mt-3">
        <button
          id="save"
          class="w-full bg-surface text-text border border-border rounded-md py-2 text-sm font-medium cursor-pointer hover:bg-surface transition-colors"
        >
          Save
        </button>
      </div>

      <div id="error" class="text-danger text-xs mt-4"></div>
    </div>

    <p class="mt-auto pt-8 pb-4 text-[10px] text-muted">end-to-end encrypted</p>

    <script type="module">
      import { importKey, decrypt } from "/crypto.js";

      const metaEl = document.getElementById("meta");
      const metaName = document.getElementById("meta-name");
      const metaSize = document.getElementById("meta-size");
      const metaExpiry = document.getElementById("meta-expiry");
      const burnWarning = document.getElementById("burn-warning");
      const loadBtn = document.getElementById("load-btn");
      const contentWrapper = document.getElementById("content-wrapper");
      const contentEl = document.getElementById("content");
      const imageContainer = document.getElementById("image-container");
      const imageEl = document.getElementById("image-el");
      const binaryContainer = document.getElementById("binary-container");
      const binaryName = document.getElementById("binary-name");
      const burnNotice = document.getElementById("burn-notice");
      const imageActions = document.getElementById("image-actions");
      const copyBtn = document.getElementById("copy");
      const rawBtn = document.getElementById("raw");
      const downloadBtn = document.getElementById("download");
      const saveBtn = document.getElementById("save");
      const errorEl = document.getElementById("error");

      let decryptedText = "";

      const IMAGE_EXTS = new Set([
        "png",
        "jpg",
        "jpeg",
        "gif",
        "webp",
        "svg",
        "ico",
        "bmp",
        "tiff",
        "avif",
      ]);
      const TEXT_EXTS = new Set([
        "txt",
        "md",
        "js",
        "ts",
        "jsx",
        "tsx",
        "json",
        "yaml",
        "yml",
        "toml",
        "xml",
        "html",
        "css",
        "sh",
        "py",
        "rb",
        "go",
        "rs",
        "java",
        "c",
        "cpp",
        "h",
        "php",
        "sql",
        "csv",
        "log",
        "ini",
        "env",
      ]);
      const IMAGE_MIME = {
        png: "image/png",
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        gif: "image/gif",
        webp: "image/webp",
        svg: "image/svg+xml",
        ico: "image/x-icon",
        bmp: "image/bmp",
        tiff: "image/tiff",
        avif: "image/avif",
      };

      function getExt(name) {
        const parts = name.split(".");
        return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : "";
      }

      function formatBytes(n) {
        if (n < 1024) return `${n} B`;
        if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
        if (n < 1024 * 1024 * 1024) return `${(n / 1024 / 1024).toFixed(1)} MB`;
        return `${(n / 1024 / 1024 / 1024).toFixed(2)} GB`;
      }

      function formatExpiry(unixSec) {
        const secs = unixSec - Math.floor(Date.now() / 1000);
        if (secs < 60) return "expires in less than a minute";
        if (secs < 3600) return `expires in ${Math.floor(secs / 60)}m`;
        if (secs < 86400) return `expires in ${Math.floor(secs / 3600)}h`;
        return `expires in ${Math.floor(secs / 86400)}d`;
      }

      function triggerDownload(blob, fileName) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 60000);
      }

      async function load() {
        const id = location.pathname.split("/p/")[1];
        const keyEncoded = location.hash.slice(1);

        if (!id || !keyEncoded) {
          errorEl.textContent = "Invalid URL.";
          return;
        }

        const key = await importKey(keyEncoded);

        // HEAD â€” get metadata without fetching or burning the file
        const headRes = await fetch(`/api/file/${id}`, { method: "HEAD" });
        if (!headRes.ok) {
          errorEl.textContent = "File not found or expired.";
          return;
        }

        const burnAfterRead = headRes.headers.get("X-Burn-After-Read") === "1";
        const expiresAt = parseInt(headRes.headers.get("X-Expires-At") || "0");
        const size = parseInt(headRes.headers.get("Content-Length") || "0");

        metaName.textContent = "Encrypted file";
        metaSize.textContent = formatBytes(size);
        metaExpiry.textContent = formatExpiry(expiresAt);
        loadBtn.textContent = "View";
        if (burnAfterRead) burnWarning.classList.remove("hidden");
        metaEl.classList.remove("hidden");

        loadBtn.addEventListener("click", async () => {
          loadBtn.disabled = true;
          loadBtn.textContent = "Decrypting\u2026";

          try {
            const res = await fetch(`/api/file/${id}`);
            if (!res.ok) {
              errorEl.textContent = "File not found or expired.";
              return;
            }

            const buf = await res.arrayBuffer();
            const { fileName, fileData } = await decrypt(new Uint8Array(buf), key);
            const ext = getExt(fileName);

            metaEl.classList.add("hidden");

            if (burnAfterRead) burnNotice.classList.remove("hidden");

            if (IMAGE_EXTS.has(ext)) {
              const mime = IMAGE_MIME[ext] || "image/png";
              const blob = new Blob([fileData], { type: mime });
              imageEl.src = URL.createObjectURL(blob);
              imageEl.alt = fileName;
              imageContainer.classList.remove("hidden");
              imageActions.classList.remove("hidden");
              saveBtn.addEventListener("click", () =>
                triggerDownload(blob, fileName),
              );
            } else if (TEXT_EXTS.has(ext)) {
              decryptedText = new TextDecoder().decode(fileData);
              contentEl.textContent = decryptedText;
              contentWrapper.classList.remove("hidden");
            } else {
              const blob = new Blob([fileData]);
              binaryName.textContent = fileName;
              binaryContainer.classList.remove("hidden");
              downloadBtn.addEventListener("click", () =>
                triggerDownload(blob, fileName),
              );
            }
          } catch (e) {
            errorEl.textContent = "Failed to decrypt. The key may be wrong.";
            loadBtn.disabled = false;
            loadBtn.textContent = "Retry";
          }
        });
      }

      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(decryptedText);
        copyBtn.title = "Copied!";
        setTimeout(() => (copyBtn.title = "Copy"), 1500);
      });

      rawBtn.addEventListener("click", () => {
        const w = window.open();
        w.document.write(`<pre>${decryptedText.replace(/</g, "&lt;")}</pre>`);
      });

      load();
    </script>
  </body>
</html>
